(ns lonelyplanet.core
  (:require [clojure.tools.cli :as cli]
            [clojure.string :as s]
            [clojure.java.io :as io]
            [lonelyplanet.model :as m]
            [lonelyplanet.view :as v]
            )
  (:gen-class))

(def cli-options [["-h" "--help" "Show this help message."]
                  ["-t" "--taxonomy FILENAME" "Supply an alternate filename for the taxonomy.xml file."
                   :default "taxonomy.xml" ]
                  ["-d" "--destinations FILENAME" "Supply an alternate filename for the destinations.xml file."
                   :default "destinations.xml"]])

(defn usage
  "Generate help text for the CLI. Options-summary is expected to be a string (generated by tools.cli/parse-opts)."
  [options-summary]
  (s/join
    \newline
    ["Lonely Planet August 2014 coding test by Oliver Mooney (August 2015)"
     "Usage: lonely [options] input-directory output-directory"
     "The input directory should contain two files, named taxonomy.xml and destinations.xml."
     "These filenames can be overriden using the options below."
     "Options show switches (short then long), defaults, and option effects."
     ""
     options-summary
     ""]))

(defn- error-msg
  "Generate an error message from the error map supplied by tools.cli/parse-opts"
  [errors]
  (str "Invocation errors: \n" (s/join \newline errors)))

(defn exit
  "Generate exit text on completion/error. Supply standard unix codes for exit status, and any text for msg."
  [status msg]
  (println msg)
  (System/exit status))

(defn gen-reader
  "Convert a filename into a file reader ready for processing. Filename can be presented in parent-child fragments,
   or as a single path."
  [& paths]
  (->> paths (apply io/file) io/input-stream io/reader))

(defn process-files
  "Generate the HTML files from the supplied taxonomy and destinations files, saving them to the output directory."
  [{:keys [taxonomy destinations output-dir]}]
  (let [{:keys [destinations dest-metas hierarchy]} (m/generate-destinations taxonomy destinations)]
    (doall (pmap (fn [destination]
                   (let [output-file (io/file output-dir (str (get-in destination [:meta :place-id]) ".html"))]
                     (spit output-file (v/render-destination destination dest-metas hierarchy))))
                 destinations))))

(defn validate-invocation
  "Check invocation arguments, options etc for valid invocation"
  [{:keys [options arguments errors summary]}]
  (cond (:help options) (exit 0 (usage summary))
        (not= (count arguments) 2) (exit 1 (usage summary))
        errors (exit 1 (error-msg errors))))

(defn -main
  "Parse commandline options & arguments, & respond accordingly. Main entry point."
  [& args]
  (let [{:keys [options arguments errors summary] :as invocation} (cli/parse-opts args cli-options)]
    (validate-invocation invocation)
    (try (with-open [taxonomy (gen-reader (first arguments) (:taxonomy options))
                     destinations (gen-reader (first arguments) (:destinations options))
                     ]
           (let [output (second arguments)]
             (process-files {:taxonomy taxonomy :destinations destinations :output-dir output})
             (exit 0 (str "Files processed & saved to " output))))
         (catch Exception e
           (exit 1 (str "Exception: " (.getMessage e)))))))
